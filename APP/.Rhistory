x = "Nom",
y = input$ycol) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
)
})
# Créer une carte interactive
output$map <- renderLeaflet({
leaflet(fruits_legumes_fleurs) %>%
addTiles() %>%
addMarkers(
lng = ~ 2.3522, # Exemple de longitude
lat = ~ 48.8566, # Exemple de latitude
popup = ~ paste(Nom, "<br>", "Type: ", Type, "<br>", "Saison: ", Saison)
)
})
}
# Exécuter l'application
shinyApp(ui = ui, server = server)
elecdf <- read_delim("eCO2mix_RTE_En-cours-Consolide.csv",
delim = ";", escape_double = FALSE, trim_ws = TRUE)
runif(n = 15)
?runif()
setwd("C:/Users/royky/Documents/Reporting-d-une-analyse-multivari-e/APP")
shiny::runApp()
# =============================================================================
# ANALYSE MULTIVARIÉE - DÉVELOPPEMENT DES COMMUNES ET PYRAMIDE DE MASLOW
# =============================================================================
# Chargement des packages nécessaires
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
tidyverse,      # Manipulation de données
corrplot,       # Matrice de corrélation
FactoMineR,     # ACP et analyses factorielles
factoextra,     # Visualisation des analyses factorielles
cluster,        # Classification
ggplot2,        # Graphiques
plotly,         # Graphiques interactifs
knitr,          # Rapports
kableExtra,     # Tableaux
RColorBrewer,   # Palettes de couleurs
psych,          # Statistiques descriptives
car,            # Tests statistiques
GGally,         # Matrice de graphiques
reshape2,       # Restructuration de données
gridExtra       # Arrangement de graphiques
)
# =============================================================================
# 1. CHARGEMENT ET PRÉPARATION DES DONNÉES
# =============================================================================
# Lecture du fichier CSV
# Adaptez le chemin selon votre fichier
data <- read.csv("Communes10-20K-Maslow.csv", sep = ";", header = TRUE, stringsAsFactors = FALSE)
# Aperçu des données
cat("=== APERÇU DES DONNÉES ===\n")
head(data)
str(data)
summary(data)
# Variables de la pyramide de Maslow
maslow_vars <- c("Physiologique", "Sécurité", "Appartenance", "Estime",
"Actualisation.de.soi", "Cognitif")
# Variables démographiques
demo_vars <- c("PMUN", "PCAP", "PTOT")
# Création d'indicateurs dérivés
data <- data %>%
mutate(
# Densité de population
Densité = PTOT / 1000,  # Ajustez selon vos données
# Ratio population municipale/population totale
Ratio_PMUN = PMUN / PTOT,
# Score total des équipements
Score_Total = Physiologique + Sécurité + Appartenance + Estime +
Actualisation.de.soi + Cognitif,
# Équipements par habitant
Équip_par_hab = Score_Total / PTOT * 1000,
# Classification taille commune
Taille_Commune = case_when(
PTOT < 2000 ~ "Petite",
PTOT < 10000 ~ "Moyenne",
PTOT < 50000 ~ "Grande",
TRUE ~ "Très Grande"
),
# Profil Maslow dominant
Profil_Dominant = case_when(
Physiologique == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif) ~ "Physiologique",
Sécurité == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif) ~ "Sécurité",
Appartenance == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif) ~ "Appartenance",
Estime == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif) ~ "Estime",
Actualisation.de.soi == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif) ~ "Actualisation",
TRUE ~ "Cognitif"
)
)
# =============================================================================
# 2. STATISTIQUES DESCRIPTIVES
# =============================================================================
cat("\n=== STATISTIQUES DESCRIPTIVES ===\n")
# Statistiques des variables Maslow
stats_maslow <- data %>%
select(all_of(maslow_vars)) %>%
describe() %>%
round(2)
print(stats_maslow)
# Statistiques par taille de commune
stats_taille <- data %>%
group_by(Taille_Commune) %>%
summarise(
n = n(),
Pop_Moyenne = mean(PTOT, na.rm = TRUE),
Score_Moyen = mean(Score_Total, na.rm = TRUE),
Équip_par_hab_Moyen = mean(Équip_par_hab, na.rm = TRUE),
.groups = 'drop'
) %>%
arrange(desc(Pop_Moyenne))
print(stats_taille)
# =============================================================================
# 3. ANALYSE DE CORRÉLATION
# =============================================================================
cat("\n=== ANALYSE DE CORRÉLATION ===\n")
# Matrice de corrélation
cor_matrix <- cor(data[c(maslow_vars, demo_vars, "Score_Total", "Équip_par_hab")],
use = "complete.obs")
# Graphique de corrélation
png("correlation_matrix.png", width = 800, height = 600)
corrplot(cor_matrix, method = "color", type = "upper",
order = "hclust", tl.cex = 0.8, tl.col = "black")
dev.off()
# Test de significativité des corrélations
cor_test <- corr.test(data[c(maslow_vars, demo_vars, "Score_Total", "Équip_par_hab")])
# =============================================================================
# 4. ANALYSE EN COMPOSANTES PRINCIPALES (ACP)
# =============================================================================
cat("\n=== ANALYSE EN COMPOSANTES PRINCIPALES ===\n")
# Préparation des données pour l'ACP
data_acp <- data %>%
select(all_of(maslow_vars)) %>%
na.omit()
# ACP
acp <- PCA(data_acp, graph = FALSE)
# Valeurs propres
eigenvalues <- get_eigenvalue(acp)
print(eigenvalues)
# Contribution des variables
contrib_var <- get_pca_var(acp)$contrib
print(contrib_var)
# Graphiques ACP
p1 <- fviz_eig(acp, addlabels = TRUE, ylim = c(0, 50))
p2 <- fviz_pca_var(acp, col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE)
p3 <- fviz_pca_biplot(acp, repel = TRUE, col.var = "#2E9FDF", col.ind = "#696969")
# Sauvegarde des graphiques
ggsave("acp_eigenvalues.png", p1, width = 10, height = 6)
ggsave("acp_variables.png", p2, width = 10, height = 8)
ggsave("acp_biplot.png", p3, width = 12, height = 8)
# =============================================================================
# 5. CLASSIFICATION HIÉRARCHIQUE
# =============================================================================
cat("\n=== CLASSIFICATION HIÉRARCHIQUE ===\n")
# Standardisation des données
data_std <- scale(data_acp)
# Classification hiérarchique
hc <- hclust(dist(data_std), method = "ward.D2")
# Dendrogramme
png("dendrogramme.png", width = 1200, height = 800)
plot(hc, main = "Classification Hiérarchique des Communes",
xlab = "Communes", ylab = "Distance")
rect.hclust(hc, k = 4, border = 2:5)
dev.off()
# Détermination du nombre optimal de clusters
fviz_nbclust(data_std, kmeans, method = "wss") +
ggtitle("Méthode du coude pour déterminer k optimal")
ggsave("optimal_clusters.png", width = 10, height = 6)
# K-means avec k=4
set.seed(123)
km <- kmeans(data_std, centers = 4, nstart = 25)
# Ajout des clusters aux données
data$Cluster <- as.factor(km$cluster)
# Visualisation des clusters
fviz_cluster(km, data = data_std,
palette = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
geom = "point", ellipse.type = "convex",
ggtheme = theme_bw()) +
ggtitle("Classification K-means des Communes")
ggsave("kmeans_clusters.png", width = 12, height = 8)
# =============================================================================
# 6. ANALYSE DISCRIMINANTE
# =============================================================================
cat("\n=== ANALYSE DISCRIMINANTE ===\n")
# Analyse discriminante par taille de commune
library(MASS)
lda_model <- lda(Taille_Commune ~ Physiologique + Sécurité + Appartenance +
Estime + Actualisation.de.soi + Cognitif, data = data)
# =============================================================================
# ANALYSE MULTIVARIÉE - DÉVELOPPEMENT DES COMMUNES ET PYRAMIDE DE MASLOW
# =============================================================================
# Chargement des packages nécessaires
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
tidyverse,      # Manipulation de données
corrplot,       # Matrice de corrélation
FactoMineR,     # ACP et analyses factorielles
factoextra,     # Visualisation des analyses factorielles
cluster,        # Classification
ggplot2,        # Graphiques
plotly,         # Graphiques interactifs
knitr,          # Rapports
kableExtra,     # Tableaux
RColorBrewer,   # Palettes de couleurs
psych,          # Statistiques descriptives
car,            # Tests statistiques
GGally,         # Matrice de graphiques
reshape2,       # Restructuration de données
gridExtra       # Arrangement de graphiques
)
# =============================================================================
# 1. CHARGEMENT ET PRÉPARATION DES DONNÉES
# =============================================================================
# Lecture du fichier CSV
# Adaptez le chemin selon votre fichier
data <- read.csv("Communes10-20K-Maslow.csv", sep = ";", header = TRUE, stringsAsFactors = FALSE)
# Aperçu des données
cat("=== APERÇU DES DONNÉES ===\n")
head(data)
str(data)
summary(data)
# Variables de la pyramide de Maslow
maslow_vars <- c("Physiologique", "Sécurité", "Appartenance", "Estime",
"Actualisation.de.soi", "Cognitif")
# Variables démographiques
demo_vars <- c("PMUN", "PCAP", "PTOT")
# VÉRIFICATIONS PRÉLIMINAIRES IMPORTANTES
cat("=== VÉRIFICATIONS DES DONNÉES ===\n")
# Vérification des valeurs manquantes
cat("Valeurs manquantes par colonne:\n")
print(colSums(is.na(data)))
# Vérification des valeurs nulles ou négatives
cat("\nValeurs nulles ou négatives dans les variables clés:\n")
problematic_vars <- c("PMUN", "PCAP", "PTOT", maslow_vars)
for(var in problematic_vars) {
if(var %in% names(data)) {
null_count <- sum(data[[var]] <= 0, na.rm = TRUE)
if(null_count > 0) {
cat(paste(var, ":", null_count, "valeurs <= 0\n"))
}
}
}
# Création d'indicateurs dérivés avec gestion des erreurs
data <- data %>%
mutate(
# Densité de population (éviter division par zéro)
Densité = ifelse(PTOT > 0, PTOT / 1000, NA),  # Ajustez selon vos données
# Ratio population municipale/population totale (éviter division par zéro)
Ratio_PMUN = ifelse(PTOT > 0, PMUN / PTOT, NA),
# Score total des équipements
Score_Total = Physiologique + Sécurité + Appartenance + Estime +
Actualisation.de.soi + Cognitif,
# Équipements par habitant (éviter division par zéro)
Équip_par_hab = ifelse(PTOT > 0, Score_Total / PTOT * 1000, NA),
# Classification taille commune
Taille_Commune = case_when(
is.na(PTOT) ~ "Non définie",
PTOT < 2000 ~ "Petite",
PTOT < 10000 ~ "Moyenne",
PTOT < 50000 ~ "Grande",
TRUE ~ "Très Grande"
),
# Profil Maslow dominant (avec gestion des NA)
Profil_Dominant = case_when(
is.na(Physiologique) | is.na(Sécurité) | is.na(Appartenance) |
is.na(Estime) | is.na(Actualisation.de.soi) | is.na(Cognitif) ~ "Non défini",
Physiologique == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif, na.rm = TRUE) ~ "Physiologique",
Sécurité == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif, na.rm = TRUE) ~ "Sécurité",
Appartenance == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif, na.rm = TRUE) ~ "Appartenance",
Estime == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif, na.rm = TRUE) ~ "Estime",
Actualisation.de.soi == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif, na.rm = TRUE) ~ "Actualisation",
TRUE ~ "Cognitif"
)
)
# Nettoyage automatique des données
cat("\n=== NETTOYAGE AUTOMATIQUE DES DONNÉES ===\n")
# Fonction de nettoyage
nettoyer_donnees <- function(df) {
df_clean <- df %>%
# Remplacer les valeurs infinies par NA
mutate(across(where(is.numeric), ~ifelse(is.infinite(.), NA, .))) %>%
# Remplacer les valeurs aberrantes par NA (plus de 3 écarts-types)
mutate(across(all_of(maslow_vars), ~ifelse(abs(scale(.)[,1]) > 3, NA, .))) %>%
# Supprimer les lignes où toutes les variables Maslow sont NA
filter(!if_all(all_of(maslow_vars), is.na))
return(df_clean)
}
# Application du nettoyage
data_original <- data  # Sauvegarde
data <- nettoyer_donnees(data)
cat("Données avant nettoyage:", nrow(data_original), "lignes\n")
cat("Données après nettoyage:", nrow(data), "lignes\n")
cat("Lignes supprimées:", nrow(data_original) - nrow(data), "\n")
# =============================================================================
# 2. STATISTIQUES DESCRIPTIVES
# =============================================================================
cat("\n=== STATISTIQUES DESCRIPTIVES ===\n")
# Statistiques des variables Maslow
stats_maslow <- data %>%
select(all_of(maslow_vars)) %>%
describe() %>%
round(2)
# =============================================================================
# ANALYSE MULTIVARIÉE - DÉVELOPPEMENT DES COMMUNES ET PYRAMIDE DE MASLOW
# =============================================================================
# Chargement des packages nécessaires
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
tidyverse,      # Manipulation de données
corrplot,       # Matrice de corrélation
FactoMineR,     # ACP et analyses factorielles
factoextra,     # Visualisation des analyses factorielles
cluster,        # Classification
ggplot2,        # Graphiques
plotly,         # Graphiques interactifs
knitr,          # Rapports
kableExtra,     # Tableaux
RColorBrewer,   # Palettes de couleurs
psych,          # Statistiques descriptives
car,            # Tests statistiques
GGally,         # Matrice de graphiques
reshape2,       # Restructuration de données
gridExtra       # Arrangement de graphiques
)
# =============================================================================
# 1. CHARGEMENT ET PRÉPARATION DES DONNÉES
# =============================================================================
# Lecture du fichier CSV
# Adaptez le chemin selon votre fichier
data <- read.csv("votre_fichier.csv", sep = ";", header = TRUE, stringsAsFactors = FALSE)
# =============================================================================
# ANALYSE MULTIVARIÉE - DÉVELOPPEMENT DES COMMUNES ET PYRAMIDE DE MASLOW
# =============================================================================
# Chargement des packages nécessaires
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
tidyverse,      # Manipulation de données
corrplot,       # Matrice de corrélation
FactoMineR,     # ACP et analyses factorielles
factoextra,     # Visualisation des analyses factorielles
cluster,        # Classification
ggplot2,        # Graphiques
plotly,         # Graphiques interactifs
knitr,          # Rapports
kableExtra,     # Tableaux
RColorBrewer,   # Palettes de couleurs
psych,          # Statistiques descriptives
car,            # Tests statistiques
GGally,         # Matrice de graphiques
reshape2,       # Restructuration de données
gridExtra       # Arrangement de graphiques
)
# =============================================================================
# 1. CHARGEMENT ET PRÉPARATION DES DONNÉES
# =============================================================================
# Lecture du fichier CSV
# Adaptez le chemin selon votre fichier
data <- read.csv("Communes10K-20K-Maslow.csv", sep = ";", header = TRUE, stringsAsFactors = FALSE)
# =============================================================================
# ANALYSE MULTIVARIÉE - DÉVELOPPEMENT DES COMMUNES ET PYRAMIDE DE MASLOW
# =============================================================================
# Chargement des packages nécessaires
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
tidyverse,      # Manipulation de données
corrplot,       # Matrice de corrélation
FactoMineR,     # ACP et analyses factorielles
factoextra,     # Visualisation des analyses factorielles
cluster,        # Classification
ggplot2,        # Graphiques
plotly,         # Graphiques interactifs
knitr,          # Rapports
kableExtra,     # Tableaux
RColorBrewer,   # Palettes de couleurs
psych,          # Statistiques descriptives
car,            # Tests statistiques
GGally,         # Matrice de graphiques
reshape2,       # Restructuration de données
gridExtra       # Arrangement de graphiques
)
# =============================================================================
# 1. CHARGEMENT ET PRÉPARATION DES DONNÉES
# =============================================================================
# Lecture du fichier CSV
# Adaptez le chemin selon votre fichier
data <- read.csv("Communes10-20K-Maslow.csv", sep = ";", header = TRUE, stringsAsFactors = FALSE)
# Aperçu des données
cat("=== APERÇU DES DONNÉES ===\n")
head(data)
str(data)
summary(data)
# Variables de la pyramide de Maslow
maslow_vars <- c("Physiologique", "Sécurité", "Appartenance", "Estime",
"Actualisation.de.soi", "Cognitif")
# Variables démographiques
demo_vars <- c("PMUN", "PCAP", "PTOT")
# VÉRIFICATIONS PRÉLIMINAIRES IMPORTANTES
cat("=== VÉRIFICATIONS DES DONNÉES ===\n")
# Vérification des valeurs manquantes
cat("Valeurs manquantes par colonne:\n")
print(colSums(is.na(data)))
# Vérification des valeurs nulles ou négatives
cat("\nValeurs nulles ou négatives dans les variables clés:\n")
problematic_vars <- c("PMUN", "PCAP", "PTOT", maslow_vars)
for(var in problematic_vars) {
if(var %in% names(data)) {
null_count <- sum(data[[var]] <= 0, na.rm = TRUE)
if(null_count > 0) {
cat(paste(var, ":", null_count, "valeurs <= 0\n"))
}
}
}
# Création d'indicateurs dérivés avec gestion des erreurs
data <- data %>%
mutate(
# Densité de population (éviter division par zéro)
Densité = ifelse(PTOT > 0, PTOT / 1000, NA),  # Ajustez selon vos données
# Ratio population municipale/population totale (éviter division par zéro)
Ratio_PMUN = ifelse(PTOT > 0, PMUN / PTOT, NA),
# Score total des équipements
Score_Total = Physiologique + Sécurité + Appartenance + Estime +
Actualisation.de.soi + Cognitif,
# Équipements par habitant (éviter division par zéro)
Équip_par_hab = ifelse(PTOT > 0, Score_Total / PTOT * 1000, NA),
# Classification taille commune (adaptée pour 10K-20K habitants)
Taille_Commune = case_when(
is.na(PTOT) ~ "Non définie",
PTOT < 12000 ~ "Petite (10-12K)",
PTOT < 15000 ~ "Moyenne (12-15K)",
PTOT < 18000 ~ "Grande (15-18K)",
TRUE ~ "Très Grande (18-20K)"
),
# Classification alternative plus fine
Quartile_Pop = case_when(
is.na(PTOT) ~ "Non défini",
PTOT <= quantile(PTOT, 0.25, na.rm = TRUE) ~ "Q1 (Moins peuplées)",
PTOT <= quantile(PTOT, 0.50, na.rm = TRUE) ~ "Q2",
PTOT <= quantile(PTOT, 0.75, na.rm = TRUE) ~ "Q3",
TRUE ~ "Q4 (Plus peuplées)"
),
# Profil Maslow dominant (avec gestion des NA)
Profil_Dominant = case_when(
is.na(Physiologique) | is.na(Sécurité) | is.na(Appartenance) |
is.na(Estime) | is.na(Actualisation.de.soi) | is.na(Cognitif) ~ "Non défini",
Physiologique == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif, na.rm = TRUE) ~ "Physiologique",
Sécurité == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif, na.rm = TRUE) ~ "Sécurité",
Appartenance == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif, na.rm = TRUE) ~ "Appartenance",
Estime == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif, na.rm = TRUE) ~ "Estime",
Actualisation.de.soi == pmax(Physiologique, Sécurité, Appartenance, Estime,
Actualisation.de.soi, Cognitif, na.rm = TRUE) ~ "Actualisation",
TRUE ~ "Cognitif"
)
)
# Nettoyage automatique des données
cat("\n=== NETTOYAGE AUTOMATIQUE DES DONNÉES ===\n")
# Fonction de nettoyage
nettoyer_donnees <- function(df) {
df_clean <- df %>%
# Remplacer les valeurs infinies par NA
mutate(across(where(is.numeric), ~ifelse(is.infinite(.), NA, .))) %>%
# Remplacer les valeurs aberrantes par NA (plus de 3 écarts-types)
mutate(across(all_of(maslow_vars), ~ifelse(abs(scale(.)[,1]) > 3, NA, .))) %>%
# Supprimer les lignes où toutes les variables Maslow sont NA
filter(!if_all(all_of(maslow_vars), is.na))
return(df_clean)
}
# Application du nettoyage
data_original <- data  # Sauvegarde
data <- nettoyer_donnees(data)
cat("Données avant nettoyage:", nrow(data_original), "lignes\n")
cat("Données après nettoyage:", nrow(data), "lignes\n")
cat("Lignes supprimées:", nrow(data_original) - nrow(data), "\n")
# =============================================================================
# 2. STATISTIQUES DESCRIPTIVES - ADAPTÉES POUR COMMUNES 10K-20K
# =============================================================================
cat("\n=== STATISTIQUES DESCRIPTIVES - COMMUNES 10K-20K HABITANTS ===\n")
# Vérification de la plage de population
cat("Plage de population dans les données:\n")
cat("Minimum:", min(data$PTOT, na.rm = TRUE), "\n")
cat("Maximum:", max(data$PTOT, na.rm = TRUE), "\n")
cat("Médiane:", median(data$PTOT, na.rm = TRUE), "\n")
# Histogramme de la population
hist_pop <- ggplot(data, aes(x = PTOT)) +
geom_histogram(bins = 20, fill = "steelblue", alpha = 0.7, color = "white") +
geom_vline(aes(xintercept = median(PTOT, na.rm = TRUE)),
color = "red", linetype = "dashed", size = 1) +
labs(title = "Distribution de la population (10K-20K habitants)",
x = "Population totale", y = "Nombre de communes") +
theme_minimal()
ggsave("distribution_population.png", hist_pop, width = 10, height = 6)
# Statistiques des variables Maslow
stats_maslow <- data %>%
select(all_of(maslow_vars)) %>%
describe() %>%
round(2)
